#include <iostream>
#include <thread>
#include <atomic>
#include <chrono>
#include <sstream>

// ============================================
// КЛАСС СОБСТВЕННОГО МЬЮТЕКСА (MyMutex)
// ============================================

class MyMutex {
private:
    std::atomic<bool> locked;  // Флаг: true - заблокирован, false - свободен

public:
    MyMutex() : locked(false) {}

    // Метод lock (захват мьютекса)
    void lock() {
        bool expected = false;
        // Пытаемся атомарно изменить locked с false на true
        while (!locked.compare_exchange_weak(expected, true,
            std::memory_order_acquire)) {
            expected = false;  // Сбрасываем для следующей попытки
            std::this_thread::yield();  // Уступаем процессор
        }
    }

    // Метод unlock (освобождение мьютекса)
    void unlock() {
        locked.store(false, std::memory_order_release);
    }
};

// ============================================
// ГЛОБАЛЬНЫЕ ПЕРЕМЕННЫЕ И ОБЪЕКТЫ
// ============================================

// Используем наш собственный мьютекс вместо std::mutex
MyMutex mtx;
MyMutex cout_mtx;  // Для синхронизации вывода

// Тарелки с наггетсами
int dish1 = 3000;
int dish2 = 3000;
int dish3 = 3000;

// Флаги для синхронизации
std::atomic<bool> cook_can_serve(true);
std::atomic<bool> fatman1_can_eat(false);
std::atomic<bool> fatman2_can_eat(false);
std::atomic<bool> fatman3_can_eat(false);

// Счетчики съеденных наггетсов
int eaten1 = 0;
int eaten2 = 0;
int eaten3 = 0;

// Флаги состояния
std::atomic<bool> cook_fired(false);
std::atomic<bool> cook_no_salary(false);
std::atomic<bool> cook_quit(false);

// Время работы (5 дней = 5 секунд)
const int WORK_DAYS = 5;

// ============================================
// ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ
// ============================================

// Функция для преобразования числа в строку
std::string int_to_string(int value) {
    std::stringstream ss;
    ss << value;
    return ss.str();
}

// Функция для безопасного вывода с нашим мьютексом
void safe_print(const std::string& message) {
    cout_mtx.lock();  // Используем наш lock()
    std::cout << message << std::endl;
    cout_mtx.unlock();  // Используем наш unlock()
}

// Класс для автоматического управления нашим мьютексом (аналог lock_guard)
class MyLockGuard {
private:
    MyMutex& m_mutex;

public:
    explicit MyLockGuard(MyMutex& mutex) : m_mutex(mutex) {
        m_mutex.lock();
    }

    ~MyLockGuard() {
        m_mutex.unlock();
    }

    // Запрещаем копирование
    MyLockGuard(const MyLockGuard&) = delete;
    MyLockGuard& operator=(const MyLockGuard&) = delete;
};

// ============================================
// ФУНКЦИЯ ПОВАРА
// ============================================

void cook(int efficiency_factor) {
    auto start_time = std::chrono::steady_clock::now();

    while (true) {
        // Проверяем прошло ли 5 дней
        auto current_time = std::chrono::steady_clock::now();
        auto elapsed = std::chrono::duration_cast<std::chrono::seconds>(
            current_time - start_time).count();

        if (elapsed >= WORK_DAYS) {
            cook_quit = true;
            safe_print("Кук: Устал! Увольняюсь сам! (прошло " +
                int_to_string(WORK_DAYS) + " дней)");
            return;
        }

        // Ждем разрешения выкладывать еду
        while (!cook_can_serve) {
            std::this_thread::yield();
        }

        // Используем наш lock_guard с нашим мьютексом
        MyLockGuard lock(mtx);

        // Выкладываем наггетсы
        dish1 += efficiency_factor;
        dish2 += efficiency_factor;
        dish3 += efficiency_factor;

        safe_print("Кук выложил по " + int_to_string(efficiency_factor) +
            " наггетсов. Тарелки: " + int_to_string(dish1) + ", " +
            int_to_string(dish2) + ", " + int_to_string(dish3));

        // Разрешаем толстякам есть
        cook_can_serve = false;
        fatman1_can_eat = true;
        fatman2_can_eat = true;
        fatman3_can_eat = true;

        // Проверяем условие увольнения
        if (dish1 <= 0 || dish2 <= 0 || dish3 <= 0) {
            cook_fired = true;
            safe_print("Кук: Меня уволили! Одна из тарелок пуста!");
            return;
        }

        // Небольшая пауза между циклами
        std::this_thread::sleep_for(std::chrono::milliseconds(10));
    }
}

// ============================================
// ФУНКЦИЯ ТОЛСТЯКА
// ============================================

void fatman(int fatman_id, int* dish, int* eaten, int gluttony,
    std::atomic<bool>& can_eat) {
    while (true) {
        // Проверяем условия завершения
        if (cook_fired || cook_quit || cook_no_salary) {
            return;
        }

        // Проверяем, не съели ли слишком много
        if (*eaten > 10000) {
            safe_print("Толстяк " + int_to_string(fatman_id) +
                " лопнул! Съел " + int_to_string(*eaten) + " наггетсов");
            return;
        }

        // Ждем разрешения есть
        while (!can_eat) {
            std::this_thread::yield();
        }

        // Используем наш lock_guard с нашим мьютексом
        MyLockGuard lock(mtx);

        // Едим наггетсы
        int to_eat = gluttony;
        if (to_eat > *dish) {
            to_eat = *dish;
        }
        *dish -= to_eat;
        *eaten += to_eat;

        if (to_eat > 0) {
            safe_print("Толстяк " + int_to_string(fatman_id) + " съел " +
                int_to_string(to_eat) + " наггетсов. Осталось в тарелке: " +
                int_to_string(*dish) + ", всего съедено: " + int_to_string(*eaten));
        }

        // Сигнализируем, что поел
        can_eat = false;

        // Если все толстяки поели, разрешаем повару работать
        if (!fatman1_can_eat && !fatman2_can_eat && !fatman3_can_eat) {
            cook_can_serve = true;
        }

        // Проверяем условие "не получил зарплату"
        if (eaten1 > 10000 && eaten2 > 10000 && eaten3 > 10000) {
            cook_no_salary = true;
            safe_print("Все толстяки лопнули! Кук не получит зарплату!");
            return;
        }

        // Небольшая пауза между циклами
        std::this_thread::sleep_for(std::chrono::milliseconds(10));
    }
}

// ============================================
// ФУНКЦИЯ ДЛЯ ЗАПУСКА СИМУЛЯЦИИ
// ============================================

void run_simulation(int efficiency_factor, int gluttony,
    const std::string& scenario_name) {
    std::cout << "\n" << std::string(50, '=') << std::endl;
    std::cout << "Сценарий: " << scenario_name << std::endl;
    std::cout << "Используется СОБСТВЕННЫЙ мьютекс MyMutex" << std::endl;
    std::cout << "Параметры: efficiency_factor = " << efficiency_factor
        << ", gluttony = " << gluttony << std::endl;
    std::cout << std::string(50, '=') << std::endl;

    // Сбрасываем глобальные переменные
    dish1 = dish2 = dish3 = 3000;
    eaten1 = eaten2 = eaten3 = 0;
    cook_can_serve = true;
    fatman1_can_eat = fatman2_can_eat = fatman3_can_eat = false;
    cook_fired = cook_no_salary = cook_quit = false;

    // Запускаем потоки
    std::thread cook_thread(cook, efficiency_factor);
    std::thread fatman1(fatman, 1, &dish1, &eaten1, gluttony,
        std::ref(fatman1_can_eat));
    std::thread fatman2(fatman, 2, &dish2, &eaten2, gluttony,
        std::ref(fatman2_can_eat));
    std::thread fatman3(fatman, 3, &dish3, &eaten3, gluttony,
        std::ref(fatman3_can_eat));

    // Ждем завершения потоков
    cook_thread.join();
    fatman1.join();
    fatman2.join();
    fatman3.join();

    // Выводим результат
    std::cout << "\nИтоги сценария \"" << scenario_name << "\":" << std::endl;
    std::cout << "Съедено: Т1=" << eaten1 << ", Т2=" << eaten2
        << ", Т3=" << eaten3 << std::endl;
    std::cout << "Осталось в тарелках: " << dish1 << ", "
        << dish2 << ", " << dish3 << std::endl;

    if (cook_fired) {
        std::cout << "Результат: Кука уволили!" << std::endl;
    }
    else if (cook_no_salary) {
        std::cout << "Результат: Кук не получил зарплату!" << std::endl;
    }
    else if (cook_quit) {
        std::cout << "Результат: Кук уволился сам!" << std::endl;
    }
    else {
        std::cout << "Результат: Не определен!" << std::endl;
    }
    std::cout << std::string(50, '=') << "\n" << std::endl;

    // Пауза между симуляциями
    std::this_thread::sleep_for(std::chrono::seconds(1));
}

// ============================================
// ГЛАВНАЯ ФУНКЦИЯ
// ============================================

int main() {
    setlocale(LC_ALL, "rus");
    std::cout << "ЛАБОРАТОРНАЯ РАБОТА №5: СОБСТВЕННЫЙ МЬЮТЕКС" << std::endl;
    std::cout << "Реализация MyMutex на основе atomic и compare_exchange" << std::endl;
    std::cout << std::string(60, '=') << "\n" << std::endl;

    // Демонстрация работы собственного мьютекса
    std::cout << "Демонстрация работы MyMutex:" << std::endl;

    MyMutex test_mutex;

    // Тест 1: Базовый lock/unlock
    std::cout << "1. Тест lock/unlock: ";
    test_mutex.lock();
    std::cout << "Мьютекс заблокирован" << std::endl;
    test_mutex.unlock();
    std::cout << "Мьютекс разблокирован" << std::endl;

    // Тест 2: MyLockGuard
    std::cout << "2. Тест MyLockGuard: ";
    {
        MyLockGuard guard(test_mutex);
        std::cout << "В области действия MyLockGuard" << std::endl;
    }
    std::cout << "Выход из области действия - мьютекс автоматически разблокирован"
        << std::endl;

    std::cout << "\n" << std::string(60, '-') << "\n" << std::endl;

    // Запускаем три сценария как в лабораторной №4
    run_simulation(1, 50, "Кука уволили");
    run_simulation(50, 100, "Кук не получил зарплату");
    run_simulation(5, 5, "Кук уволился сам");

    std::cout << "\n" << std::string(60, '=') << std::endl;
    std::cout << "ВЫВОДЫ:" << std::endl;
    std::cout << "1. Собственный мьютекс MyMutex работает корректно" << std::endl;
    std::cout << "2. Результаты идентичны использованию std::mutex" << std::endl;
    std::cout << "3. MyMutex обеспечивает взаимное исключение через atomic" << std::endl;
    std::cout << "4. Все условия лабораторной №4 выполняются" << std::endl;
    std::cout << std::string(60, '=') << std::endl;

    return 0;
}
